<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>如何在node项目中接入ChatGpt</title>
    <link href="/2023/03/09/%E5%A6%82%E4%BD%95%E5%9C%A8node%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%8E%A5%E5%85%A5ChatGpt/"/>
    <url>/2023/03/09/%E5%A6%82%E4%BD%95%E5%9C%A8node%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%8E%A5%E5%85%A5ChatGpt/</url>
    
    <content type="html"><![CDATA[<p>ChatGPT是一个由OpenAI推出的聊天机器人API，它能够利用深度学习技术生成人类般的自然语言回复。在本文中，我们将介绍如何在Node.js项目中接入ChatGPT。</p><span id="more"></span><ol><li>注册并获取API密钥</li></ol><p>​首先，你需要在OpenAI网站上注册并获取API密钥。在登录后，导航到API密钥页面，创建一个新的API密钥并复制你的密钥。这个密钥将用于在你的应用程序中进行身份验证。</p><ol start="2"><li>安装OpenAI包</li></ol><p>​你需要在Node.js项目中安装OpenAI包，可以使用npm包管理器来安装。运行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install openai<br></code></pre></td></tr></table></figure><ol start="3"><li>创建OpenAI客户端</li></ol><p>​接下来，你需要创建一个OpenAI客户端实例，以便在你的应用程序中使用ChatGPT API。你可以通过提供你的API密钥来创建客户端实例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> openai = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;openai&#x27;</span>);<br><span class="hljs-keyword">const</span> client = <span class="hljs-keyword">new</span> openai.<span class="hljs-title function_">api</span>(<span class="hljs-variable constant_">YOUR_API_KEY</span>);<br></code></pre></td></tr></table></figure><ol start="4"><li>调用ChatGPT API</li></ol><p>现在你已经设置了OpenAI客户端，你可以使用该客户端调用ChatGPT API并获取机器人回复。以下是一个简单的示例代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> prompt = <span class="hljs-string">&#x27;你好，我可以帮你什么？&#x27;</span>;<br><span class="hljs-keyword">const</span> temperature = <span class="hljs-number">0.5</span>;<br><span class="hljs-keyword">const</span> maxTokens = <span class="hljs-number">100</span>;<br><br>client.<span class="hljs-property">completions</span>.<span class="hljs-title function_">create</span>(&#123;<br>  <span class="hljs-attr">engine</span>: <span class="hljs-string">&#x27;davinci&#x27;</span>,<br>  <span class="hljs-attr">prompt</span>: prompt,<br>  <span class="hljs-attr">max_tokens</span>: maxTokens,<br>  <span class="hljs-attr">temperature</span>: temperature<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> &#123;choices&#125; = response.<span class="hljs-property">choices</span>[<span class="hljs-number">0</span>];<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(choices[<span class="hljs-number">0</span>].<span class="hljs-property">text</span>);<br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error);<br>&#125;);<br></code></pre></td></tr></table></figure><p>在上面的示例中，我们首先定义了一个输入提示，然后设置了温度和最大标记数量。然后，我们调用了<code>completions.create()</code>函数来获取ChatGPT的回复，并在控制台输出了机器人的回复。</p><ol start="5"><li>完整的示例代码</li></ol><p>这是一个完整的Node.js示例代码，它演示了如何使用OpenAI包来接入ChatGPT API：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> openai = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;openai&#x27;</span>);<br><span class="hljs-keyword">const</span> client = <span class="hljs-keyword">new</span> openai.<span class="hljs-title function_">api</span>(<span class="hljs-variable constant_">YOUR_API_KEY</span>);<br><br><span class="hljs-keyword">const</span> prompt = <span class="hljs-string">&#x27;你好，我可以帮你什么？&#x27;</span>;<br><span class="hljs-keyword">const</span> temperature = <span class="hljs-number">0.5</span>;<br><span class="hljs-keyword">const</span> maxTokens = <span class="hljs-number">100</span>;<br><br>client.<span class="hljs-property">completions</span>.<span class="hljs-title function_">create</span>(&#123;<br>  <span class="hljs-attr">engine</span>: <span class="hljs-string">&#x27;davinci&#x27;</span>,<br>  <span class="hljs-attr">prompt</span>: prompt,<br>  <span class="hljs-attr">max_tokens</span>: maxTokens,<br>  <span class="hljs-attr">temperature</span>: temperature<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> &#123;choices&#125; = response.<span class="hljs-property">choices</span>[<span class="hljs-number">0</span>];<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(choices[<span class="hljs-number">0</span>].<span class="hljs-property">text</span>);<br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error);<br>&#125;);<br></code></pre></td></tr></table></figure><ol start="6"><li>结论</li></ol><p>在本文中，我们介绍了如何在Node.js项目中接入ChatGPT API。通过使用OpenAI包，我们可以轻松地与ChatGPT进行通信，并获取自然语言的回复。在实际应用中，你可以根据自己的需求和场景，调整输入提示、温度、最大标记数量等参数来获取不同的回复。希望本文能够对你有所帮助！</p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ChatGpt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker前端入门与了解</title>
    <link href="/2022/11/06/Docker%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E4%B8%8E%E4%BA%86%E8%A7%A3/"/>
    <url>/2022/11/06/Docker%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E4%B8%8E%E4%BA%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>随着云计算技术的发展，Docker已经成为一种广泛使用的容器化解决方案。在前端开发领域，Docker的应用也日益普及。本文将为大家介绍前端Docker入门知识，包括什么是Docker，如何使用Docker容器化前端应用，以及一些常用的Docker命令和实例。</p><span id="more"></span><h4 id="Docker-前端部署的优点"><a href="#Docker-前端部署的优点" class="headerlink" title="Docker 前端部署的优点"></a>Docker 前端部署的优点</h4><p>在以往的前端部署过程中，开发人员通常需要手动安装各种依赖库、配置开发环境、打包发布等一系列的操作，而这些操作可能因为不同的环境而有所不同，还容易出现人为的错误。<br>而使用Docker，我们可以将应用程序及其依赖项打包成一个可移植的容器，这意味着在不同的开发和生产环境中，应用程序的运行环境都是相同的。这样可以大大降低应用程序出现问题的概率，提高应用程序的可靠性和稳定性。<br>同时，Docker容器的快速部署和管理能力也大大简化了前端开发人员的工作，可以极大提高前端开发人员的生产效率。</p><h4 id="Docker-的安装和配置"><a href="#Docker-的安装和配置" class="headerlink" title="Docker 的安装和配置"></a>Docker 的安装和配置</h4><p>在使用Docker之前，我们需要先安装和配置Docker。如果你还没安装Docker，可以参考上一篇文章安装和配置Docker。安装完成后，我们可以通过在终端或命令行中输入以下命令检查Docker的版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker --version<br></code></pre></td></tr></table></figure><p>如果安装成功，会显示Docker的版本号。</p><h4 id="Dockerfile的编写"><a href="#Dockerfile的编写" class="headerlink" title="Dockerfile的编写"></a>Dockerfile的编写</h4><p>在Docker中，我们使用Dockerfile文件定义容器镜像的构建流程。Dockerfile包含了一系列的指令，用来描述如何构建Docker镜像。<br>以下是一个简单的Dockerfile示例，可以将一个基于Vue.js的前端应用程序打包成一个Docker容器：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># 基于官方的Node.js镜像</span><br><span class="hljs-keyword">FROM</span> node:<span class="hljs-number">12</span>-alpine<br><br><span class="hljs-comment"># 设置工作目录</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /app</span><br><br><span class="hljs-comment"># 复制应用程序源代码到容器中</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> . /app</span><br><br><span class="hljs-comment"># 安装依赖</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> npm install</span><br><br><span class="hljs-comment"># 构建生产环境下的前端资源</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> npm run build</span><br><br><span class="hljs-comment"># 启动应用程序</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;npm&quot;</span>, <span class="hljs-string">&quot;start&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>使用上述Dockerfile，我们可以通过以下命令来构建和启动Docker容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">构建Docker镜像</span><br>docker build -t my-vue-app .<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">启动Docker容器</span><br>docker run -p 8080:80 my-vue-app<br></code></pre></td></tr></table></figure><p>在上面的Dockerfile中，我们使用了<code>FROM</code>指令来基于官方的Node.js 12镜像来创建一个新的Docker镜像。将当前目录下的所有文件复制到容器中的<code>/app</code>目录下，然后安装依赖，构建前端资源，最后启动应用程序。</p><h4 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h4><p>当我们需要部署多个相关的Docker容器时，手动启动和管理这些容器将会变得非常困难。在这种情况下，我们可以使用Docker Compose工具来帮助我们管理多个相关的Docker容器。<br>Docker Compose使用一个YAML文件来定义所有需要启动的容器，以及它们之间的依赖关系。以下是一个简单的Docker Compose配置文件示例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3&#x27;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">my-vue-app:</span><br>    <span class="hljs-attr">build:</span> <span class="hljs-string">.</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;8080:80&quot;</span><br>  <span class="hljs-attr">my-nginx:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.21-alpine</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;80:80&quot;</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">./nginx.conf:/etc/nginx/nginx.conf</span><br>    <span class="hljs-attr">depends_on:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">my-vue-app</span><br></code></pre></td></tr></table></figure><p>在上面的配置文件中，我们定义了两个服务：<code>my-vue-app</code>和<code>my-nginx</code>。<code>my-vue-app</code>是我们之前创建的Vue.js应用程序的Docker容器。<code>my-nginx</code>是一个Nginx的Docker容器，用来作为反向代理服务器，将所有请求代理到<code>my-vue-app</code>容器中。<br>使用以下命令启动Docker Compose：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker-compose up<br></code></pre></td></tr></table></figure><p>在Docker Compose启动后，我们可以通过<code>http://localhost</code>来访问我们的Vue.js应用程序。Nginx服务器会将所有请求代理到<code>my-vue-app</code>容器中。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>通过Docker，我们可以将应用程序及其依赖项打包成一个可移植的容器，使得我们可以快速地部署和管理应用程序。同时，Docker还提供了Docker Compose工具，用于管理多个相关的Docker容器。<br>本文提供了一个简单的示例，帮助初学者快速上手使用Docker来部署前端项目。希望本文能够对您有所帮助。</p>]]></content>
    
    
    <categories>
      
      <category>部署与运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>部署</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker简介与安装使用</title>
    <link href="/2022/11/05/Docker%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/11/05/Docker%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>Docker是一种轻量级的容器化解决方案，它可以将应用程序及其依赖项打包成一个可移植的容器，使得我们可以快速地部署和管理应用程序。</p><span id="more"></span><h4 id="Docker-简介"><a href="#Docker-简介" class="headerlink" title="Docker 简介"></a>Docker 简介</h4><p>Docker是一种轻量级的容器化解决方案，它可以将应用程序及其依赖项打包成一个可移植的容器，使得我们可以快速地部署和管理应用程序。使用Docker，我们可以避免开发和运行环境之间的不一致问题，使得我们的应用程序在不同的环境中运行时都具有相同的表现。与传统的虚拟机技术不同，Docker容器不需要运行完整的操作系统，而是只需要运行应用程序及其依赖项。这使得Docker容器比传统的虚拟机更轻量级，启动速度更快，同时也占用更少的资源。</p><h4 id="Docker-与虚拟机的区别"><a href="#Docker-与虚拟机的区别" class="headerlink" title="Docker 与虚拟机的区别"></a>Docker 与虚拟机的区别</h4><p>传统的虚拟机技术是通过虚拟化硬件来实现多个操作系统的隔离。每个虚拟机都需要运行一个完整的操作系统及其依赖项，这导致虚拟机非常重量级，启动速度慢，同时也占用更多的资源。与之相比，Docker容器是通过共享宿主机操作系统的内核来实现隔离的。每个Docker容器只需要运行应用程序及其依赖项，而不需要运行完整的操作系统。这使得Docker容器比传统的虚拟机更轻量级，启动速度更快，同时也占用更少的资源。</p><h4 id="Docker-安装"><a href="#Docker-安装" class="headerlink" title="Docker 安装"></a>Docker 安装</h4><p>安装Docker的方法因不同的操作系统而异。以下是在Ubuntu系统上安装Docker的步骤：</p><ol><li>更新apt软件包索引：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get update<br></code></pre></td></tr></table></figure><ol start="2"><li>安装Docker依赖包：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install apt-transport-https ca-certificates curl gnupg-agent software-properties-common<br></code></pre></td></tr></table></figure><ol start="3"><li>添加Docker的GPG密钥：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -<br></code></pre></td></tr></table></figure><ol start="4"><li>添加Docker的APT源：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo add-apt-repository <span class="hljs-string">&quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu <span class="hljs-subst">$(lsb_release -cs)</span> stable&quot;</span><br></code></pre></td></tr></table></figure><ol start="5"><li>更新apt软件包索引：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get update<br></code></pre></td></tr></table></figure><ol start="6"><li>安装Docker：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install docker-ce docker-ce-cli containerd.io<br></code></pre></td></tr></table></figure><p>安装完成后，您可以通过运行以下命令来检查Docker是否已经正确安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo docker run hello-world<br></code></pre></td></tr></table></figure><p>如果Docker已经正确安装，您将会看到一条欢迎消息。</p><h4 id="常用Docker命令"><a href="#常用Docker命令" class="headerlink" title="常用Docker命令"></a>常用Docker命令</h4><p>下面列出一些常用的Docker命令，以帮助您更好地使用Docker：</p><ul><li><code>docker build</code>: 构建Docker镜像</li><li><code>docker run</code>: 启动一个新的Docker容器</li><li><code>docker stop</code>: 停止运行中的Docker容器</li><li><code>docker start</code>: 启动已经停止的Docker容器</li><li><code>docker ps</code>: 列出所有正在运行的Docker容器</li><li><code>docker images</code>: 列出所有本地的Docker镜像</li><li><code>docker exec</code>: 在运行中的Docker容器中执行命令</li><li><code>docker-compose up</code>: 启动Docker Compose</li><li><code>docker-compose down</code>: 停止Docker Compose</li></ul>]]></content>
    
    
    <categories>
      
      <category>部署与运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微前端框架qiankun的分析介绍</title>
    <link href="/2022/10/29/%E5%BE%AE%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6qiankun%E7%9A%84%E5%88%86%E6%9E%90%E4%BB%8B%E7%BB%8D/"/>
    <url>/2022/10/29/%E5%BE%AE%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6qiankun%E7%9A%84%E5%88%86%E6%9E%90%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<p>阿里巴巴在2020年开源了一款微前端框架qiankun，它具有简单易用和高效灵活的特点，广受开发者好评。本文将详细介绍qiankun的实现原理，分析其优缺点，并给出使用建议。</p><span id="more"></span><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>微前端架构是一种将多个独立的前端应用整合在一个页面中的架构。qiankun的实现原理如下：<br>主应用作为容器，通过控制子应用的加载和卸载，实现对子应用的管理。子应用以独立的模块运行，并通过qiankun提供的API与主应用进行通信。qiankun通过对子应用的生命周期进行管理，实现了对子应用的加载和卸载。通过qiankun提供的API，主应用可以在不同的时间节点注册对子应用的控制，从而实现对子应用的管理。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">// 主应用注册子应用 </span><br><span class="hljs-title function_ invoke__">registerMicroApps</span>([<br>  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;app1&#x27;</span>, <span class="hljs-attr">entry</span>: <span class="hljs-string">&#x27;//localhost:7100&#x27;</span>, <span class="hljs-attr">container</span>: <span class="hljs-string">&#x27;#subapp-container&#x27;</span>, <span class="hljs-attr">activeRule</span>: <span class="hljs-string">&#x27;/app1&#x27;</span> &#125;,<br>  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;app2&#x27;</span>, <span class="hljs-attr">entry</span>: <span class="hljs-string">&#x27;//localhost:7101&#x27;</span>, <span class="hljs-attr">container</span>: <span class="hljs-string">&#x27;#subapp-container&#x27;</span>, <span class="hljs-attr">activeRule</span>: <span class="hljs-string">&#x27;/app2&#x27;</span> &#125;,<br>]);<br><span class="hljs-comment">// 主应用启动qiankun</span><br><span class="hljs-title function_ invoke__">start</span>();<br><br></code></pre></td></tr></table></figure><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ol><li>独立部署：qiankun支持子应用独立部署，每个子应用可以单独开发，部署和维护，不影响其他子应用的正常运行。</li><li>高效灵活：qiankun支持动态加载和卸载子应用，在不影响主应用性能的情况下实现了对子应用的管理。</li><li>易于使用：qiankun的API简单易用，易于集成到主应用中，不需要复杂的配置即可使用。</li></ol><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><p>浏览器兼容性：qiankun目前只支持现代浏览器，对于不支持HTML5的浏览器可能存在兼容性问题。<br>限制较多：qiankun对子应用的限制较多，例如不支持使用window.location进行跳转等。</p><h4 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h4><ol><li>适用于中大型项目：qiankun适用于中大型项目，对于小型项目可能不够灵活。</li><li>合理规划项目架构：在使用qiankun之前，需要合理规划项目架构，以便更好地实现微前端架构。</li><li>注意浏览器兼容性：使用qiankun时需要注意浏览器兼容性问题，尽量使用现代浏览器进行测试。</li></ol><h4 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h4><p>qiankun是一款优秀的微前端框架，其独立部署、高效灵活、易于使用等优点使得它成为了微前端领域的一个重要选择。但是，它也存在一些缺点，例如浏览器兼容性较差、限制较多等，因此使用qiankun需要仔细考虑。在使用qiankun之前，需要考虑项目的规模和架构，并且注意浏览器兼容性问题，以便更好地实现微前端架构。最后，建议在实际项目中多多体验和实践，以深入了解qiankun的优缺点，并在实际需求和场景中进行合理选择和使用。</p>]]></content>
    
    
    <categories>
      
      <category>微前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>qiankun</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微前端:一种新的前端开发模式</title>
    <link href="/2022/10/15/%E5%BE%AE%E5%89%8D%E7%AB%AF-%E4%B8%80%E7%A7%8D%E6%96%B0%E7%9A%84%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/10/15/%E5%BE%AE%E5%89%8D%E7%AB%AF-%E4%B8%80%E7%A7%8D%E6%96%B0%E7%9A%84%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>微前端是一种新的前端开发模式，它提供了一种解决前端巨石应用程序(monolithic)的方法，同时保持代码的可维护性和可扩展性。</p><span id="more"></span><p>微前端的概念最早出现在2016年，但直到近几年才开始在前端开发领域得到广泛应用。这种模式的核心思想是将大型复杂的前端应用程序分解成若干个独立的、可独立部署的小型前端应用程序，从而实现前端代码的分治和复用。</p><h4 id="微前端的优势"><a href="#微前端的优势" class="headerlink" title="微前端的优势"></a>微前端的优势</h4><p>微前端模式带来了许多优势，其中包括：</p><ol><li>提高团队效率：微前端模式可以让团队更加专注于自己负责的代码，减少代码冲突，提高团队协作效率。</li><li>保持代码可维护性：微前端模式可以让团队更好地维护自己的代码，并且更容易进行代码审核。</li><li>提高代码复用性：微前端模式可以让各个团队的代码相互独立，从而提高代码的复用性。</li><li>提高开发效率：微前端模式可以让团队快速开发出高质量的代码，并且减少了代码的重复开发。</li><li>提高灵活性：微前端模式可以让团队根据需要快速调整应用程序的架构，从而提高系统的灵活性。</li></ol><h4 id="微前端的实现方案"><a href="#微前端的实现方案" class="headerlink" title="微前端的实现方案"></a>微前端的实现方案</h4><p>目前，微前端的实现方案有很多，包括：</p><ol><li>基于Iframe的方案：这种方案通过使用Iframe嵌套不同的前端应用程序来实现微前端。</li><li>基于Single-SPA的方案：这种方案是目前最流行的微前端实现方案之一，它通过使用Single-SPA框架来实现微前端。</li><li>基于微服务的方案：这种方案将前端应用程序看作微服务，通过微服务架构来实现微前端。</li></ol><h4 id="微前端方案的优劣对比"><a href="#微前端方案的优劣对比" class="headerlink" title="微前端方案的优劣对比"></a>微前端方案的优劣对比</h4><p>不同的微前端实现方案各有优劣，在选择方案时需要根据具体情况进行判断。</p><ol><li>基于Iframe的方案简单易用，但是会存在一些缺点，例如数据共享难以实现、页面布局不统一等。</li><li>基于Single-SPA的方案更加灵活，可以解决Iframe方案存在的问题，但是需要对Single-SPA框架有一定的了解，开发者需要在使用过程中注意一些细节问题。</li><li>基于微服务的方案更加稳定，可以解决微前端在解决数据共享问题上的瓶颈，但是开发者需要对微服务架构有一定了解，并且这种方案的开发周期较长，适用于大型复杂项目。</li></ol><h4 id="适用场景建议"><a href="#适用场景建议" class="headerlink" title="适用场景建议"></a>适用场景建议</h4><ol><li>如果是小型项目，建议使用基于Iframe的方案，因为它简单易用。</li><li>如果是中型项目，建议使用基于Single-SPA的方案，因为它更加灵活，能够解决Iframe方案存在的问题。</li><li>如果是大型复杂项目，建议使用基于微服务的方案，因为它更加稳定，能够解决微前端在解决数据共享问题上的瓶颈。</li></ol><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>微前端是当前前端开发的一种重要趋势，它可以帮助团队提高开发效率，提高系统的稳定性和灵活性。在选择微前端实现方案时，需要根据具体情况进行判断，并选择适合自己项目的方案。<br>希望本文能够对大家了解微前端有所帮助。</p>]]></content>
    
    
    <categories>
      
      <category>微前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微前端</tag>
      
      <tag>微前端概念介绍</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>axios 封装</title>
    <link href="/2022/09/03/axios%E5%B0%81%E8%A3%85/"/>
    <url>/2022/09/03/axios%E5%B0%81%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<p>不管是在 vue 项目还是 react 项目中,前端常用的 request 请求库都是 axios,所以本文就提供了一个 axios 封装,实现了一个灵活、可复用的一个请求请发.</p><span id="more"></span><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;axios&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">ElLoading</span>, <span class="hljs-title class_">ElMessage</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;element-plus&quot;</span>;<br><span class="hljs-comment">// 获取token,如果你的项目有其他获取toke的方式请替换这里</span><br><span class="hljs-keyword">import</span> &#123; getTokenAUTH &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@/utils/auth&quot;</span>;<br><br><span class="hljs-keyword">const</span> pendingMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">LoadingInstance</span> = &#123;<br>  <span class="hljs-attr">_target</span>: <span class="hljs-literal">null</span>,<br>  <span class="hljs-attr">_count</span>: <span class="hljs-number">0</span>,<br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">myAxios</span>(<span class="hljs-params">axiosConfig, customOptions, loadingOptions</span>) &#123;<br>  <span class="hljs-keyword">const</span> service = axios.<span class="hljs-title function_">create</span>(&#123;<br>    <span class="hljs-attr">baseURL</span>: <span class="hljs-string">&quot;http://localhost:8888&quot;</span>, <span class="hljs-comment">// 设置统一的请求前缀</span><br>    <span class="hljs-attr">timeout</span>: <span class="hljs-number">10000</span>, <span class="hljs-comment">// 设置统一的超时时长</span><br>  &#125;);<br><br>  <span class="hljs-comment">// 自定义配置</span><br>  <span class="hljs-keyword">let</span> custom_options = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(<br>    &#123;<br>      <span class="hljs-attr">repeat_request_cancel</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 是否开启取消重复请求, 默认为 true</span><br>      <span class="hljs-attr">loading</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 是否开启loading层效果, 默认为false</span><br>      <span class="hljs-attr">reduct_data_format</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 是否开启简洁的数据结构响应, 默认为true</span><br>      <span class="hljs-attr">error_message_show</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 是否开启接口错误信息展示,默认为true</span><br>      <span class="hljs-attr">code_message_show</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 是否开启code不为0时的信息提示, 默认为false</span><br>    &#125;,<br>    customOptions<br>  );<br><br>  <span class="hljs-comment">// 请求拦截</span><br>  service.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(<br>    <span class="hljs-function">(<span class="hljs-params">config</span>) =&gt;</span> &#123;<br>      <span class="hljs-title function_">removePending</span>(config);<br>      custom_options.<span class="hljs-property">repeat_request_cancel</span> &amp;&amp; <span class="hljs-title function_">addPending</span>(config);<br>      <span class="hljs-comment">// 创建loading实例</span><br>      <span class="hljs-keyword">if</span> (custom_options.<span class="hljs-property">loading</span>) &#123;<br>        <span class="hljs-title class_">LoadingInstance</span>.<span class="hljs-property">_count</span>++;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-title class_">LoadingInstance</span>.<span class="hljs-property">_count</span> === <span class="hljs-number">1</span>) &#123;<br>          <span class="hljs-title class_">LoadingInstance</span>.<span class="hljs-property">_target</span> = <span class="hljs-title class_">ElLoading</span>.<span class="hljs-title function_">service</span>(loadingOptions);<br>        &#125;<br>      &#125;<br>      <span class="hljs-comment">// 自动携带token</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">getTokenAUTH</span>() &amp;&amp; <span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">window</span> !== <span class="hljs-string">&quot;undefined&quot;</span>) &#123;<br>        config.<span class="hljs-property">headers</span>.<span class="hljs-property">Authorization</span> = <span class="hljs-title function_">getTokenAUTH</span>();<br>      &#125;<br><br>      <span class="hljs-keyword">return</span> config;<br>    &#125;,<br>    <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error);<br>    &#125;<br>  );<br><br>  <span class="hljs-comment">// 响应拦截</span><br>  service.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<br>    <span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> &#123;<br>      <span class="hljs-title function_">removePending</span>(response.<span class="hljs-property">config</span>);<br>      custom_options.<span class="hljs-property">loading</span> &amp;&amp; <span class="hljs-title function_">closeLoading</span>(custom_options); <span class="hljs-comment">// 关闭loading</span><br><br>      <span class="hljs-keyword">if</span> (<br>        custom_options.<span class="hljs-property">code_message_show</span> &amp;&amp;<br>        response.<span class="hljs-property">data</span> &amp;&amp;<br>        response.<span class="hljs-property">data</span>.<span class="hljs-property">code</span> !== <span class="hljs-number">0</span><br>      ) &#123;<br>        <span class="hljs-title class_">ElMessage</span>(&#123;<br>          <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;error&quot;</span>,<br>          <span class="hljs-attr">message</span>: response.<span class="hljs-property">data</span>.<span class="hljs-property">message</span>,<br>        &#125;);<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(response.<span class="hljs-property">data</span>); <span class="hljs-comment">// code不等于0, 页面具体逻辑就不执行了</span><br>      &#125;<br><br>      <span class="hljs-keyword">return</span> custom_options.<span class="hljs-property">reduct_data_format</span> ? response.<span class="hljs-property">data</span> : response;<br>    &#125;,<br>    <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>      error.<span class="hljs-property">config</span> &amp;&amp; <span class="hljs-title function_">removePending</span>(error.<span class="hljs-property">config</span>);<br>      custom_options.<span class="hljs-property">loading</span> &amp;&amp; <span class="hljs-title function_">closeLoading</span>(custom_options); <span class="hljs-comment">// 关闭loading</span><br>      custom_options.<span class="hljs-property">error_message_show</span> &amp;&amp; <span class="hljs-title function_">httpErrorStatusHandle</span>(error); <span class="hljs-comment">// 处理错误状态码</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error); <span class="hljs-comment">// 错误继续返回给到具体页面</span><br>    &#125;<br>  );<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">service</span>(axiosConfig);<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> myAxios;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 处理异常</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; <span class="hljs-variable">error</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">httpErrorStatusHandle</span>(<span class="hljs-params">error</span>) &#123;<br>  <span class="hljs-comment">// 处理被取消的请求</span><br>  <span class="hljs-keyword">if</span> (axios.<span class="hljs-title function_">isCancel</span>(error))<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;请求的重复请求：&quot;</span> + error.<span class="hljs-property">message</span>);<br>  <span class="hljs-keyword">let</span> message = <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-keyword">if</span> (error &amp;&amp; error.<span class="hljs-property">response</span>) &#123;<br>    <span class="hljs-keyword">switch</span> (error.<span class="hljs-property">response</span>.<span class="hljs-property">status</span>) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">302</span>:<br>        message = <span class="hljs-string">&quot;接口重定向了！&quot;</span>;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">400</span>:<br>        message = <span class="hljs-string">&quot;参数不正确！&quot;</span>;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">401</span>:<br>        message = <span class="hljs-string">&quot;您未登录，或者登录已经超时，请先登录！&quot;</span>;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">403</span>:<br>        message = <span class="hljs-string">&quot;您没有权限操作！&quot;</span>;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">404</span>:<br>        message = <span class="hljs-string">`请求地址出错: <span class="hljs-subst">$&#123;error.response.config.url&#125;</span>`</span>;<br>        <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 在正确域名下</span><br>      <span class="hljs-keyword">case</span> <span class="hljs-number">408</span>:<br>        message = <span class="hljs-string">&quot;请求超时！&quot;</span>;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">409</span>:<br>        message = <span class="hljs-string">&quot;系统已存在相同数据！&quot;</span>;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">500</span>:<br>        message = <span class="hljs-string">&quot;服务器内部错误！&quot;</span>;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">501</span>:<br>        message = <span class="hljs-string">&quot;服务未实现！&quot;</span>;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">502</span>:<br>        message = <span class="hljs-string">&quot;网关错误！&quot;</span>;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">503</span>:<br>        message = <span class="hljs-string">&quot;服务不可用！&quot;</span>;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">504</span>:<br>        message = <span class="hljs-string">&quot;服务暂时无法访问，请稍后再试！&quot;</span>;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">505</span>:<br>        message = <span class="hljs-string">&quot;HTTP版本不受支持！&quot;</span>;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-attr">default</span>:<br>        message = <span class="hljs-string">&quot;异常问题，请联系管理员！&quot;</span>;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (error.<span class="hljs-property">message</span>.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&quot;timeout&quot;</span>)) message = <span class="hljs-string">&quot;网络请求超时！&quot;</span>;<br>  <span class="hljs-keyword">if</span> (error.<span class="hljs-property">message</span>.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&quot;Network&quot;</span>))<br>    message = <span class="hljs-variable language_">window</span>.<span class="hljs-property">navigator</span>.<span class="hljs-property">onLine</span> ? <span class="hljs-string">&quot;服务端异常！&quot;</span> : <span class="hljs-string">&quot;您断网了！&quot;</span>;<br><br>  <span class="hljs-title class_">ElMessage</span>(&#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;error&quot;</span>,<br>    message,<br>  &#125;);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 关闭Loading层实例</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; <span class="hljs-variable">_options</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">closeLoading</span>(<span class="hljs-params">_options</span>) &#123;<br>  <span class="hljs-keyword">if</span> (_options.<span class="hljs-property">loading</span> &amp;&amp; <span class="hljs-title class_">LoadingInstance</span>.<span class="hljs-property">_count</span> &gt; <span class="hljs-number">0</span>) <span class="hljs-title class_">LoadingInstance</span>.<span class="hljs-property">_count</span>--;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-title class_">LoadingInstance</span>.<span class="hljs-property">_count</span> === <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-title class_">LoadingInstance</span>.<span class="hljs-property">_target</span>.<span class="hljs-title function_">close</span>();<br>    <span class="hljs-title class_">LoadingInstance</span>.<span class="hljs-property">_target</span> = <span class="hljs-literal">null</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 储存每个请求的唯一cancel回调, 以此为标识</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; <span class="hljs-variable">config</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">addPending</span>(<span class="hljs-params">config</span>) &#123;<br>  <span class="hljs-keyword">const</span> pendingKey = <span class="hljs-title function_">getPendingKey</span>(config);<br>  config.<span class="hljs-property">cancelToken</span> =<br>    config.<span class="hljs-property">cancelToken</span> ||<br>    <span class="hljs-keyword">new</span> axios.<span class="hljs-title class_">CancelToken</span>(<span class="hljs-function">(<span class="hljs-params">cancel</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (!pendingMap.<span class="hljs-title function_">has</span>(pendingKey)) &#123;<br>        pendingMap.<span class="hljs-title function_">set</span>(pendingKey, cancel);<br>      &#125;<br>    &#125;);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 删除重复的请求</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; <span class="hljs-variable">config</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">removePending</span>(<span class="hljs-params">config</span>) &#123;<br>  <span class="hljs-keyword">const</span> pendingKey = <span class="hljs-title function_">getPendingKey</span>(config);<br>  <span class="hljs-keyword">if</span> (pendingMap.<span class="hljs-title function_">has</span>(pendingKey)) &#123;<br>    <span class="hljs-keyword">const</span> cancelToken = pendingMap.<span class="hljs-title function_">get</span>(pendingKey);<br>    <span class="hljs-title function_">cancelToken</span>(pendingKey);<br>    pendingMap.<span class="hljs-title function_">delete</span>(pendingKey);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 生成唯一的每个请求的唯一key</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; <span class="hljs-variable">config</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getPendingKey</span>(<span class="hljs-params">config</span>) &#123;<br>  <span class="hljs-keyword">let</span> &#123; url, method, params, data &#125; = config;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> data === <span class="hljs-string">&quot;string&quot;</span>) data = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(data); <span class="hljs-comment">// response里面返回的config.data是个字符串对象</span><br>  <span class="hljs-keyword">return</span> [url, method, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(params), <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data)].<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;&amp;&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>axios</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS计算用户页面停留时间</title>
    <link href="/2022/07/31/JS%E8%AE%A1%E7%AE%97%E7%94%A8%E6%88%B7%E9%A1%B5%E9%9D%A2%E5%81%9C%E7%95%99%E6%97%B6%E9%97%B4/"/>
    <url>/2022/07/31/JS%E8%AE%A1%E7%AE%97%E7%94%A8%E6%88%B7%E9%A1%B5%E9%9D%A2%E5%81%9C%E7%95%99%E6%97%B6%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<p>在某些应用场景可能会遇到需要计算用户在某页面的停留时间的类似需求，特总结如下：</p><span id="more"></span><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!doctype <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;Content-Type&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;text/html; charset=utf-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>js计算页面停留时间_www.jbxue.com<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;jquery.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">onload</span>=<span class="hljs-string">&quot;init(); window.setTimeout(&#x27;show_secs()&#x27;,1);&quot;</span> <span class="hljs-attr">onbeforeunload</span>=<span class="hljs-string">&quot;return myFunction()&quot;</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 用&lt;body onload=&quot;init(); window.setTimeout(&#x27;show_secs()&#x27;,1);&quot;&gt;替换原有的&lt;body&gt; --&gt;</span><br>  <span class="hljs-comment">&lt;!--将以下代码加入html的&lt;body&gt;&lt;/body&gt;之间--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">language</span>=<span class="hljs-string">&quot;javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> ap_name = navigator.<span class="hljs-property">appName</span>;</span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> ap_vinfo = navigator.<span class="hljs-property">appVersion</span>;</span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> ap_ver = <span class="hljs-built_in">parseFloat</span>(ap_vinfo.<span class="hljs-title function_">substring</span>(<span class="hljs-number">0</span>,ap_vinfo.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&#x27;(&#x27;</span>)));<span class="hljs-comment">// 获取版本号</span></span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> time_start = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();</span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> clock_start = time_start.<span class="hljs-title function_">getTime</span>();</span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> dl_ok=<span class="hljs-literal">false</span>;</span><br><span class="language-javascript">  <span class="hljs-keyword">function</span> <span class="hljs-title function_">init</span> ()&#123;</span><br><span class="language-javascript">  <span class="hljs-keyword">if</span>(ap_name==<span class="hljs-string">&quot;netscape&quot;</span> &amp;&amp; ap_ver&gt;=<span class="hljs-number">3.0</span>)</span><br><span class="language-javascript">  dl_ok=<span class="hljs-literal">true</span>;</span><br><span class="language-javascript">  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">  <span class="hljs-comment">//已经打开页面多少秒</span></span><br><span class="language-javascript">  <span class="hljs-keyword">function</span> <span class="hljs-title function_">get_time_spent</span> ()&#123;</span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> time_now = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();</span><br><span class="language-javascript">  <span class="hljs-keyword">return</span>((time_now.<span class="hljs-title function_">getTime</span>() - clock_start)/<span class="hljs-number">1000</span>);</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">  <span class="hljs-keyword">function</span> <span class="hljs-title function_">show_secs</span> ()&#123; <span class="hljs-comment">// show the time user spent on the side</span></span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> i_total_secs = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">round</span>(<span class="hljs-title function_">get_time_spent</span>());</span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> i_secs_spent = i_total_secs % <span class="hljs-number">60</span>;</span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> i_mins_spent = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">round</span>((i_total_secs-<span class="hljs-number">30</span>)/<span class="hljs-number">60</span>);<span class="hljs-comment">//四舍五入，超60s，大于0.5，四舍五入就是1min</span></span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> s_secs_spent = <span class="hljs-string">&quot;&quot;</span> + ((i_secs_spent&gt;<span class="hljs-number">9</span>) ? i_secs_spent : <span class="hljs-string">&quot;0&quot;</span> + i_secs_spent);<span class="hljs-comment">//改显示格式：个位数-&gt; 0+个位数，如7-&gt;07</span></span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> s_mins_spent =<span class="hljs-string">&quot;&quot;</span> + ((i_mins_spent&gt;<span class="hljs-number">9</span>) ? i_mins_spent : <span class="hljs-string">&quot;0&quot;</span> + i_mins_spent);</span><br><span class="language-javascript">  <span class="hljs-variable language_">document</span>.<span class="hljs-property">fm0</span>.<span class="hljs-property">time_spent</span>.<span class="hljs-property">value</span> = s_mins_spent + <span class="hljs-string">&quot;:&quot;</span> + s_secs_spent; <span class="hljs-comment">//把值放入form中name为time_spent的input中</span></span><br><span class="language-javascript">  <span class="hljs-variable language_">window</span>.<span class="hljs-built_in">setTimeout</span>(<span class="hljs-string">&#x27;show_secs()&#x27;</span>,<span class="hljs-number">1000</span>); <span class="hljs-comment">//每隔1s刷新一次input里的值</span></span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">  <span class="hljs-comment">//参考：http://blog.csdn.net/davislien/article/details/47685831</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-comment">//----------------------beforeunload使用方法一：（需要去掉body标签里的beforeunload=&quot;myFunction()&quot;）------------------------------------</span></span><br><span class="language-javascript">  <span class="hljs-comment">//在关闭页面时弹出确认提示窗口</span></span><br><span class="language-javascript"><span class="hljs-comment">//$(window).bind(&#x27;beforeunload&#x27;, function()&#123;</span></span><br><span class="language-javascript"><span class="hljs-comment">// //alert(09999);//凡是alert在此函数里被阻止，Blocked alert(&#x27;09999&#x27;) during beforeunload.</span></span><br><span class="language-javascript"><span class="hljs-comment">// s1(2000);</span></span><br><span class="language-javascript"><span class="hljs-comment">//</span></span><br><span class="language-javascript"><span class="hljs-comment">// console.log(&quot;您在网站&quot;+ document.URL+&quot;停留时间（分：秒）：&quot;+document.fm0.time_spent.value);</span></span><br><span class="language-javascript"><span class="hljs-comment">//</span></span><br><span class="language-javascript"><span class="hljs-comment">// window.event.returnValue=&quot;1.确定要退出本页吗？&quot;;</span></span><br><span class="language-javascript"><span class="hljs-comment">//</span></span><br><span class="language-javascript"><span class="hljs-comment">//&#125;);</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-comment">//----------------------beforeunload使用方法二：（不去掉body标签里的beforeunload=&quot;myFunction()&quot;也可以，还是执行此方法二，而不是方法三）------------------------------------</span></span><br><span class="language-javascript">  <span class="hljs-comment">//测试：谷歌浏览器：刷新时只执行最后一行代码，关闭页面时三行代码都执行</span></span><br><span class="language-javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-property">onbeforeunload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>)&#123;</span><br><span class="language-javascript">  <span class="hljs-comment">//alert(09999);//凡是alert在此函数里被阻止，Blocked alert(&#x27;09999&#x27;) during beforeunload.</span></span><br><span class="language-javascript">  <span class="hljs-title function_">s1</span>(<span class="hljs-number">2000</span>);</span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> arr = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];</span><br><span class="language-javascript"><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&quot;num&quot;</span>, arr);<span class="hljs-comment">//存储数据</span></span><br><span class="language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&quot;num&quot;</span>));</span><br><span class="language-javascript">  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;您在网站&quot;</span>+ <span class="hljs-variable language_">document</span>.<span class="hljs-property">URL</span>+<span class="hljs-string">&quot;停留时间（分：秒）：&quot;</span>+<span class="hljs-variable language_">document</span>.<span class="hljs-property">fm0</span>.<span class="hljs-property">time_spent</span>.<span class="hljs-property">value</span>);</span><br><span class="language-javascript">  <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">is_confirm</span> !== <span class="hljs-literal">false</span>)&#123;</span><br><span class="language-javascript">  <span class="hljs-variable language_">window</span>.<span class="hljs-property">event</span>.<span class="hljs-property">returnValue</span>=<span class="hljs-string">&quot;2.确定要退出本页吗？&quot;</span>; <span class="hljs-comment">//刷新页面时只执行此行</span></span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-comment">//----------------------beforeunload使用方法三：（需要在body标签里的加上beforeunload=&quot;myFunction()&quot;）------------------------------------</span></span><br><span class="language-javascript">  <span class="hljs-comment">//测试：谷歌浏览器：刷新时只执行最后一行代码，关闭页面时三行代码都执行</span></span><br><span class="language-javascript">  <span class="hljs-keyword">function</span> <span class="hljs-title function_">myFunction</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">  <span class="hljs-comment">//alert(09999);//凡是alert在此函数里被阻止，Blocked alert(&#x27;09999&#x27;) during beforeunload.</span></span><br><span class="language-javascript">  <span class="hljs-title function_">s1</span>(<span class="hljs-number">2000</span>);</span><br><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;您在网站&quot;</span>+ <span class="hljs-variable language_">document</span>.<span class="hljs-property">URL</span>+<span class="hljs-string">&quot;停留时间（分：秒）：&quot;</span>+<span class="hljs-variable language_">document</span>.<span class="hljs-property">fm0</span>.<span class="hljs-property">time_spent</span>.<span class="hljs-property">value</span>);</span><br><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-variable language_">window</span>.<span class="hljs-property">event</span>.<span class="hljs-property">returnValue</span>=<span class="hljs-string">&quot;3.确定要退出本页吗？&quot;</span>; <span class="hljs-comment">//刷新页面时只执行此行</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">//js中的暂停方法一</span></span><br><span class="language-javascript">  <span class="hljs-keyword">function</span> <span class="hljs-title function_">sleep</span>(<span class="hljs-params">numberMillis</span>) &#123;</span><br><span class="language-javascript"><span class="hljs-keyword">var</span> now = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();</span><br><span class="language-javascript"><span class="hljs-keyword">var</span> exitTime = now.<span class="hljs-title function_">getTime</span>() + numberMillis;</span><br><span class="language-javascript"><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;</span><br><span class="language-javascript">now = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();</span><br><span class="language-javascript"><span class="hljs-keyword">if</span> (now.<span class="hljs-title function_">getTime</span>() &gt; exitTime)</span><br><span class="language-javascript"><span class="hljs-keyword">return</span>;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">s</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript"><span class="hljs-title function_">sleep</span>(<span class="hljs-number">2000</span>);</span><br><span class="language-javascript"><span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;您在网站&quot;</span>+ <span class="hljs-variable language_">document</span>.<span class="hljs-property">URL</span>+<span class="hljs-string">&quot;停留时间（分：秒）：&quot;</span>+<span class="hljs-variable language_">document</span>.<span class="hljs-property">fm0</span>.<span class="hljs-property">time_spent</span>.<span class="hljs-property">value</span>);</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"><span class="hljs-comment">//js中的暂停方法二</span></span><br><span class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">s1</span>(<span class="hljs-params">sec</span>)&#123;</span><br><span class="language-javascript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript"><span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;您在网站&quot;</span>+ <span class="hljs-variable language_">document</span>.<span class="hljs-property">URL</span>+<span class="hljs-string">&quot;停留时间（分：秒）：&quot;</span>+<span class="hljs-variable language_">document</span>.<span class="hljs-property">fm0</span>.<span class="hljs-property">time_spent</span>.<span class="hljs-property">value</span>);</span><br><span class="language-javascript">&#125;,sec);</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;fm0&quot;</span> <span class="hljs-attr">onsubmit</span>=<span class="hljs-string">&quot;0&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">color</span>=<span class="hljs-string">&quot;#888888&quot;</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;-1&quot;</span>&gt;</span>您在本网页的停留时间:<span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;time_spent&quot;</span> <span class="hljs-attr">size</span>=<span class="hljs-string">7</span> <span class="hljs-attr">onfocus</span>=<span class="hljs-string">&quot;this.blur()&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;暂停2秒&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;s1(2000)&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://blog.csdn.net/davislien/article/details/47685831&quot;</span>&gt;</span>参考链接<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>邮件中插入HTML代码</title>
    <link href="/2022/07/31/%E9%82%AE%E4%BB%B6%E4%B8%AD%E6%8F%92%E5%85%A5HTML%E4%BB%A3%E7%A0%81/"/>
    <url>/2022/07/31/%E9%82%AE%E4%BB%B6%E4%B8%AD%E6%8F%92%E5%85%A5HTML%E4%BB%A3%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<p>在邮件中嵌入 HTML 是常见的需求，但是由于各大邮箱客户端对 HTML 支持的不同、并且有限，所以在写这类需求的时候，需要注意一下几点：</p><span id="more"></span><ol><li>邮件使用 table+css 布局</li><li>邮件主要部分在 body 内部，所以样式一定要写成内嵌的，不能在 head 标签中写 style，也不能外联。</li><li>不能用浮动的方式定位。position：absolute;float:left;等都不行，float 在 qq 邮箱客户端中可以识别，但是在 outlook 中无法识别。</li><li>表格的 border，使用 table 上的 border 属性，可以在 qq 浏览器中兼容，但是在 outlook 中打开是没有边框的，这种情况，只能给每一个 td 加一个 border，在 table 中使用 border-collapse:collapse;来合并重复的边框。</li><li>为了保证兼容性，需要把邮件的宽度设置为 600px，最大 600px；</li><li>少用 img，因为很多邮箱客户端默认不显示图片，所以，如果需要图片的话，一定要写好 alt 和 title；</li><li>背景图片，尽量用 background-color 使用纯色背景，如果一定要用背景图片，使用 background 属性，</li><li>邮件不支持 javascript，flash 以及一些特殊的标签</li></ol><p>参考：<a href="http://www.cnblogs.com/zhangwenjiajessy/p/6132201.html">邮件中嵌入 html 中要注意的样式 - Jess_喵 - 博客园</a></p>]]></content>
    
    
    <categories>
      
      <category>html</category>
      
    </categories>
    
    
    <tags>
      
      <tag>邮件</tag>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络</title>
    <link href="/2022/07/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <url>/2022/07/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<p>梳理总结了一些常见的计算机网络相关的面试八股文,感兴趣的可以了解一下.</p><span id="more"></span><h1 id="HTTP-和-HTTPS"><a href="#HTTP-和-HTTPS" class="headerlink" title="HTTP 和 HTTPS"></a>HTTP 和 HTTPS</h1><h3 id="HTTP-的基本概念"><a href="#HTTP-的基本概念" class="headerlink" title="HTTP 的基本概念"></a>HTTP 的基本概念</h3><p>http: 是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端<code>请求和应答的标准（TCP）</code>，用于从 WWW 服务器传输超文本到本地浏览器的<code>超文本传输协议</code>。</p><h3 id="HTTP-工作原理"><a href="#HTTP-工作原理" class="headerlink" title="HTTP 工作原理"></a>HTTP 工作原理</h3><p>HTTP 协议定义 Web 客户端如何从 Web 服务器请求 Web 页面，以及服务器如何把 Web 页面传送给客户端。客户端向服务器发送一个请求报文，服务器以一个状态行作为响应。</p><h3 id="HTTP-请求-x2F-响应的步骤"><a href="#HTTP-请求-x2F-响应的步骤" class="headerlink" title="HTTP 请求&#x2F;响应的步骤"></a>HTTP 请求&#x2F;响应的步骤</h3><ul><li>1.客户端连接到 Web 服务器</li><li>2.发送 HTTP 请求</li><li>3.服务器接受请求并返回 HTTP 响应</li><li>4.释放 TCP 连接</li><li>5.客户端（浏览器）解析 HTML 内容</li></ul><blockquote><p>记忆口诀：连接发送加响应，释放解析整过程。</p></blockquote><h3 id="HTTP-的-5-种方法"><a href="#HTTP-的-5-种方法" class="headerlink" title="HTTP 的 5 种方法"></a>HTTP 的 5 种方法</h3><ul><li>GET—获取资源</li><li>POST—传输资源</li><li>PUT—更新资源</li><li>DELETE—删除资源</li><li>HEAD—获取报文首部</li></ul><h3 id="GET-与-POST-的区别"><a href="#GET-与-POST-的区别" class="headerlink" title="GET 与 POST 的区别"></a>GET 与 POST 的区别</h3><p><strong>1.浏览器回退表现不同</strong> GET 在浏览器回退时是无害的，而 POST 会再次提交请求<br><strong>2.浏览器对请求地址的处理不同</strong> GET 请求地址会被浏览器主动缓存，而 POST 不会，除非手动设置<br><strong>3.浏览器对响应的处理不同</strong>GET 请求参数会被完整的保留在浏览器历史记录里，而 POST 中的参数不会被保留<br><strong>4.参数大小不同.</strong> GET 请求在 URL 中传送的参数是有长度的限制，而 POST 没有限制<br><strong>5.安全性不同.</strong> GET 参数通过 URL 传递，会暴露，不安全；POST 放在 Request Body 中，相对更安全<br><strong>6.针对数据操作的类型不同</strong>.GET 对数据进行查询，POST 主要对数据进行增删改！简单说，GET 是只读，POST 是写。</p><h3 id="HTTP-报文的组成成分"><a href="#HTTP-报文的组成成分" class="headerlink" title="HTTP 报文的组成成分"></a>HTTP 报文的组成成分</h3><p>请求报文{ 请求行、请求头、空行、请求体 } 请求行：{http 方法、页面地址、http 协议、http 版本} 响应报文{ 状态行、响应头、空行、响应体 }</p><p><strong>Request Header:</strong></p><ol><li><strong>GET &#x2F;sample.Jsp HTTP&#x2F;1.1</strong>  &#x2F;&#x2F;请求行</li><li><strong>Host:</strong>  <a href="http://www.uuid.online/">www.uuid.online/</a> &#x2F;&#x2F;请求的目标域名和端口号</li><li><strong>Origin:</strong> <a href="http://localhost:8081/">http://localhost:8081/</a> &#x2F;&#x2F;请求的来源域名和端口号 （跨域请求时，浏览器会自动带上这个头信息）</li><li><strong>Referer:</strong> <a href="https://localhost:8081/link?query=xxxxx">https://localhost:8081/link?query=xxxxx</a> &#x2F;&#x2F;请求资源的完整 URI</li><li><strong>User-Agent:</strong> Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;67.0.3396.99 Safari&#x2F;537.36 &#x2F;&#x2F;浏览器信息</li><li><strong>Cookie:</strong>  BAIDUID&#x3D;FA89F036:FG&#x3D;1; BD_HOME&#x3D;1; sugstore&#x3D;0  &#x2F;&#x2F;当前域名下的 Cookie</li><li><strong>Accept:</strong> text&#x2F;html,image&#x2F;apng  &#x2F;&#x2F;代表客户端希望接受的数据类型是 html 或者是 png 图片类型</li><li><strong>Accept-Encoding:</strong> gzip, deflate  &#x2F;&#x2F;代表客户端能支持 gzip 和 deflate 格式的压缩</li><li><strong>Accept-Language:</strong> zh-CN,zh;q&#x3D;0.9  &#x2F;&#x2F;代表客户端可以支持语言 zh-CN 或者 zh(值得一提的是 q(0~1)是优先级权重的意思，不写默认为 1，这里 zh-CN 是 1，zh 是 0.9)</li><li><strong>Connection:</strong> keep-alive  &#x2F;&#x2F;告诉服务器，客户端需要的 tcp 连接是一个长连接</li></ol><p><strong>Response Header:</strong></p><ol><li><strong>HTTP&#x2F;1.1 200 OK</strong>  &#x2F;&#x2F;  响应状态行</li><li><strong>Date:</strong>  Mon, 30 Jul 2018 02:50:55 GMT  &#x2F;&#x2F;服务端发送资源时的服务器时间</li><li><strong>Expires:</strong>  Wed, 31 Dec 1969 23:59:59 GMT &#x2F;&#x2F;比较过时的一种验证缓存的方式，与浏览器（客户端）的时间比较，超过这个时间就不用缓存（不和服务器进行验证），适合版本比较稳定的网页</li><li><strong>Cache-Control:</strong>  no-cache  &#x2F;&#x2F; 现在最多使用的控制缓存的方式，会和服务器进行缓存验证，具体见<a href="https://www.cnblogs.com/amiezhang/p/9389537.html">博文”Cache-Control“</a></li><li><strong>etag:</strong>  “fb8ba2f80b1d324bb997cbe188f28187-ssl-df”  &#x2F;&#x2F; 一般是<a href="http://www.t086.com/article/5207">Nginx 静态服务器</a>发来的静态文件签名，浏览在没有“Disabled cache”情况下，接收到 etag 后，同一个 url 第二次请求就会自动带上“If-None-Match”</li><li><strong>Last-Modified:</strong>  Fri, 27 Jul 2018 11:04:55 GMT &#x2F;&#x2F;是服务器发来的当前资源最后一次修改的时间，下次请求时，如果服务器上当前资源的修改时间大于这个时间，就返回新的资源内容</li><li><strong>Content-Type:</strong>  text&#x2F;html; charset&#x3D;utf-8  &#x2F;&#x2F;如果返回是流式的数据，我们就必须告诉浏览器这个头，不然浏览器会下载这个页面，同时告诉浏览器是 utf8 编码，否则可能出现乱码</li><li><strong>Content-Encoding:</strong>  gzip  &#x2F;&#x2F;告诉客户端，应该采用 gzip 对资源进行解码</li><li><strong>Connection:</strong>  keep-alive  &#x2F;&#x2F;告诉客户端服务器的 tcp 连接也是一个长连接</li></ol><h3 id="https-的基本概念"><a href="#https-的基本概念" class="headerlink" title="https 的基本概念"></a>https 的基本概念</h3><p>https:是以安全为目标的 HTTP 通道，即 HTTP 下 加入 SSL 层进行加密。</p><p>https 协议的作用：建立一个信息安全通道，来确保数据的传输，确保网站的真实性。</p><h3 id="http-和-https-的区别？"><a href="#http-和-https-的区别？" class="headerlink" title="http 和 https 的区别？"></a>http 和 https 的区别？</h3><ul><li>http 是超文本传输协议，信息是明文传输，https 则是具有安全性的 ssl 加密传输协议。</li><li>Https 协议需要 ca 证书，费用较高。</li><li>使用不同的链接方式，端口也不同，一般，http 协议的端口为 80，https 的端口为 443。</li><li>http 的连接很简单，是无状态的。</li></ul><blockquote><p>记忆口诀：明文传输超文本，安全等级各不同。CA 证书费用高，无状连接端难同。</p></blockquote><h4 id="https-协议的工作原理"><a href="#https-协议的工作原理" class="headerlink" title="https 协议的工作原理"></a>https 协议的工作原理</h4><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c42bc6f45451457fa6d614fb27534516~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>客户端在使用 HTTPS 方式与 Web 服务器通信时有以下几个步骤：</p><ol><li>客户端使用 https url 访问服务器，则要求 web 服务器<code>建立 ssl 链接</code>。</li><li>web 服务器接收到客户端的请求之后，会<code>将网站的证书（证书中包含了公钥），传输给客户端</code>。</li><li>客户端和 web 服务器端开始<code>协商 SSL 链接的安全等级</code>，也就是加密等级。</li><li>客户端浏览器通过双方协商一致的安全等级，<code>建立会话密钥</code>，然后通过网站的公钥来加密会话密钥，并传送给网站。</li><li>web 服务器<code>通过自己的私钥解密出会话密钥</code>。</li><li>web 服务器<code>通过会话密钥加密与客户端之间的通信</code>。</li></ol><blockquote><p>记忆口诀：一连二传三协商，四建五得六使用。</p></blockquote><h4 id="https-协议的优缺点"><a href="#https-协议的优缺点" class="headerlink" title="https 协议的优缺点"></a>https 协议的优缺点</h4><ul><li>HTTPS 协议要比 http 协议<code>安全</code>，可防止数据在传输过程中被窃取、改变，确保数据的完整性。</li><li>https 握手阶段比较<code>费时</code>，会使页面加载时间延长 50%，增加 10%~20%的耗电。</li><li>https <code>缓存</code>不如 http 高效，会增加数据开销。</li><li>SSL 证书也需要钱，功能越强大的<code>证书费</code>用越高。</li><li>SSL 证书需要绑定 <code>IP</code>，不能再同一个 ip 上绑定多个域名，ipv4 资源支持不了这种消耗。</li></ul><h3 id="TCP-x2F-IP-网络模型"><a href="#TCP-x2F-IP-网络模型" class="headerlink" title="TCP&#x2F;IP 网络模型"></a>TCP&#x2F;IP 网络模型</h3><p>TCP&#x2F;IP 模型是互联网的基础，它是一系列网络协议的总称。这些协议可以划分为四层，分别为链路层、网络层、传输层和应用层。</p><ul><li>链路层：负责封装和解封装 IP 报文，发送和接受 ARP&#x2F;RARP 报文等。</li><li>网络层：负责路由以及把分组报文发送给目标网络或主机。</li><li>传输层：负责对报文进行分组和重组，并以 TCP 或 UDP 协议格式封装报文。</li><li>应用层：负责向用户提供应用程序，比如 HTTP、FTP、Telnet、DNS、SMTP 等。</li></ul><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2fa80b3b48a84bd18d8e708c56a1dc22~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h3 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h3><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/baf3d5df95a74f47a1d779ee50c3411f~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><ol><li>第一次握手：<code>建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认</code>；SYN：同步序列编号（Synchronize Sequence Numbers）。</li><li>第二次握手：<code>服务器收到syn包并确认客户的SYN</code>（ack&#x3D;j+1），<code>同时也发送一个自己的SYN包</code>（syn&#x3D;k），即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态；</li><li>第三次握手：<code>客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1）</code>，此包发送完毕，客户端和服务器进入 ESTABLISHED（TCP 连接成功）状态，完成三次握手。</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。<br></code></pre></td></tr></table></figure><h3 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h3><ol><li><code>客户端进程发出连接释放报文</code>，并且停止发送数据。释放数据报文首部，FIN&#x3D;1，其序列号为 seq&#x3D;u（等于前面已经传送过来的数据的最后一个字节的序号加 1），此时，客户端进入 FIN-WAIT-1（终止等待 1）状态。 TCP 规定，FIN 报文段即使不携带数据，也要消耗一个序号。</li></ol><p>2）<code>服务器收到连接释放报文，发出确认报文</code>，ACK&#x3D;1，ack&#x3D;u+1，并且带上自己的序列号 seq&#x3D;v，此时，服务端就进入了 CLOSE-WAIT（关闭等待）状态。TCP 服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个 CLOSE-WAIT 状态持续的时间。</p><p>3）客户端收到服务器的确认请求后，此时，客户端就进入 FIN-WAIT-2（终止等待 2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最 后的数据）。</p><p>4）<code>服务器将最后的数据发送完毕后，就向客户端发送连接释放报文</code>，FIN&#x3D;1，ack&#x3D;u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为 seq&#x3D;w，此时，服务器就进入了 LAST-ACK（最后确认）状态，等待客户端的确认。</p><p>5）<code>客户端收到服务器的连接释放报文后，必须发出确认</code>，ACK&#x3D;1，ack&#x3D;w+1，而自己的序列号是 seq&#x3D;u+1，此时，客户端就进入了 TIME-WAIT（时间等待）状态。注意此时 TCP 连接还没有释放，必须经过 2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的 TCB 后，才进入 CLOSED 状态。</p><p>6）服务器只要收到了客户端发出的确认，立即进入 CLOSED 状态。同样，撤销 TCB 后，就结束了这次的 TCP 连接。可以看到，服务器结束 TCP 连接的时间要比客户端早一些。</p><h3 id="TCP-和-UDP-的区别"><a href="#TCP-和-UDP-的区别" class="headerlink" title="TCP 和 UDP 的区别"></a>TCP 和 UDP 的区别</h3><ol><li><p>TCP 是面向<code>连接</code>的，而 UDP 是面向无连接的。</p></li><li><p>TCP 仅支持<code>单播传输</code>，UDP 提供了单播，多播，广播的功能。</p></li><li><p>TCP 的三次握手保证了连接的<code>可靠性</code>; UDP 是无连接的、不可靠的一种数据传输协议，首先不可靠性体现在无连接上，通信都不需要建立连接，对接收到的数据也不发送确认信号，发送端不知道数据是否会正确接收。</p></li><li><p>UDP 的<code>头部开销</code>比 TCP 的更小，数据<code>传输速率更高</code>，<code>实时性更好</code>。</p></li></ol><h3 id="HTTP-请求跨域问题"><a href="#HTTP-请求跨域问题" class="headerlink" title="HTTP 请求跨域问题"></a>HTTP 请求跨域问题</h3><ol><li><p>跨域的原理</p><p><strong>跨域</strong>，是指浏览器不能执行其他网站的脚本。它是由浏览器的<code>同源策略</code>造成的。<br><strong>同源策略</strong>,是浏览器对 JavaScript 实施的安全限制，只要<code>协议、域名、端口</code>有任何一个不同，都被当作是不同的域。<br><strong>跨域原理</strong>，即是通过各种方式，<code>避开浏览器的安全限制</code>。</p></li><li><p>解决方案</p><p>最初做项目的时候，使用的是 jsonp，但存在一些问题，使用 get 请求不安全，携带数据较小，后来也用过 iframe，但只有主域相同才行，也是存在些问题，后来通过了解和学习发现使用代理和 proxy 代理配合起来使用比较方便，就引导后台按这种方式做下服务器配置，在开发中使用 proxy，在服务器上使用 nginx 代理，这样开发过程中彼此都方便，效率也高；现在 h5 新特性还有 windows.postMessage()</p><ul><li><p><strong>JSONP</strong>：<br> ajax 请求受同源策略影响，不允许进行跨域请求，而 script 标签 src 属性中的链 接却可以访问跨域的 js 脚本，利用这个特性，服务端不再返回 JSON 格式的数据，而是 返回一段调用某个函数的 js 代码，在 src 中进行了调用，这样实现了跨域。</p><p>步骤：</p><ol><li>去创建一个 script 标签</li><li>script 的 src 属性设置接口地址</li><li>接口参数，必须要带一个自定义函数名，要不然后台无法返回数据</li><li>通过定义函数名去接受返回的数据</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//动态创建 script</span><br><span class="hljs-keyword">var</span> script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;script&quot;</span>);<br><br><span class="hljs-comment">// 设置回调函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getData</span>(<span class="hljs-params">data</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>&#125;<br><br><span class="hljs-comment">//设置 script 的 src 属性，并设置请求地址</span><br>script.<span class="hljs-property">src</span> = <span class="hljs-string">&quot;http://localhost:3000/?callback=getData&quot;</span>;<br><br><span class="hljs-comment">// 让 script 生效</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(script);<br></code></pre></td></tr></table></figure><p><strong>JSONP 的缺点</strong>:<br> JSON 只支持 get，因为 script 标签只能使用 get 请求； JSONP 需要后端配合返回指定格式的数据。</p></li><li><p><strong>document.domain</strong> 基础域名相同 子域名不同</p></li><li><p><strong>window.name</strong> 利用在一个浏览器窗口内，载入所有的域名都是共享一个 window.name</p></li><li><p><strong>CORS</strong> CORS(Cross-origin resource sharing)跨域资源共享 服务器设置对 CORS 的支持原理：服务器设置 Access-Control-Allow-Origin HTTP 响应头之后，浏览器将会允许跨域请求</p></li><li><p><strong>proxy 代理</strong> 目前常用方式</p></li><li><p><strong>window.postMessage()</strong> 利用 h5 新特性 window.postMessage()</p></li><li><p><strong>Websocket</strong></p></li></ul></li></ol><h3 id="Cookie、sessionStorage、localStorage-的区别"><a href="#Cookie、sessionStorage、localStorage-的区别" class="headerlink" title="Cookie、sessionStorage、localStorage 的区别"></a>Cookie、sessionStorage、localStorage 的区别</h3><p><strong>相同点</strong>：</p><ul><li>存储在客户端</li></ul><p><strong>不同点</strong>：</p><ul><li>cookie 数据大小不能超过 4k；sessionStorage 和 localStorage 的存储比 cookie 大得多，可以达到 5M+</li><li>cookie 设置的过期时间之前一直有效；localStorage 永久存储，浏览器关闭后数据不丢失除非主动删除数据；sessionStorage 数据在当前浏览器窗口关闭后自动删除</li><li>cookie 的数据会自动的传递到服务器；sessionStorage 和 localStorage 数据保存在本地</li></ul><h3 id="HTTP-状态码及常见状态码"><a href="#HTTP-状态码及常见状态码" class="headerlink" title="HTTP 状态码及常见状态码"></a>HTTP 状态码及常见状态码</h3><h4 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h4><ul><li>1xx：指示信息类，表示请求已接受，继续处理</li><li>2xx：指示成功类，表示请求已成功接受</li><li>3xx：指示重定向，表示要完成请求必须进行更近一步的操作</li><li>4xx：指示客户端错误，请求有语法错误或请求无法实现</li><li>5xx：指示服务器错误，服务器未能实现合法的请求</li></ul><h4 id="常见状态码"><a href="#常见状态码" class="headerlink" title="常见状态码"></a>常见状态码</h4><ul><li><p>200 OK：客户端请求成功</p></li><li><p>301 Moved Permanently：所请求的页面已经永久重定向至新的 URL</p></li><li><p>302 Found：所请求的页面已经临时重定向至新的 URL</p></li><li><p>304 Not Modified 未修改。</p></li><li><p>403 Forbidden：对请求页面的访问被禁止</p></li><li><p>404 Not Found：请求资源不存在</p></li><li><p>500 Internal Server Error：服务器发生不可预期的错误原来缓冲的文档还可以继续使用</p></li><li><p>503 Server Unavailable：请求未完成，服务器临时过载或宕机，一段时间后可恢复正常</p></li><li><p>1xx（临时响应）表示临时响应并需要请求者继续执行操作的状态码</p><ul><li>100 - 继续 请求者应当继续提出请求。服务器返回此代码表示已收到请求的第一部分，正在等待其余部分</li><li>101 - 切换协议 请求者已要求服务器切换协议，服务器已确认并准备切换</li></ul></li><li><p>2xx（成功）表示成功处理了请求的状态码</p><ul><li><code>200</code> - 成功 服务器已经成功处理了请求。通常，这表示服务器提供了请求的网页</li><li>201 - 已创建 请求成功并且服务器创建了新的资源</li><li>202 - 已接受 服务器已接受请求，但尚未处理</li><li>203 - 非授权信息 服务器已经成功处理了请求，但返回的信息可能来自另一来源</li><li>204 - 无内容 服务器成功处理了请求，但没有返回任何内容</li><li>205 - 重置内容 服务器成功处理了请求，但没有返回任何内容</li></ul></li><li><p>3xx（重定向）表示要完成请求，需要进一步操作；通常，这些状态代码用来重定向</p><ul><li>300 - 多种选择 针对请求，服务器可执行多种操作。服务器可根据请求者（user agent）选择一项操作，或提供操作列表供请求者选择</li><li><code>301</code> - 永久移动 请求的网页已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置</li><li><code>302</code> - 临时移动 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求</li><li>303 - 查看其它位置 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码</li><li><code>304</code> - 未修改 自上次请求后，请求的网页未修改过。服务器返回此响应，不会返回网页的内容</li><li>305 - 使用代理 请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理</li><li><code>307</code> - 临时性重定向 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有的位置来进行以后的请求</li></ul></li><li><p>4xx（请求错误）这些状态码表示请求可能出错，妨碍了服务器的处理</p><ul><li><code>400</code> - 错误请求 服务器不理解请求的语法</li><li><code>401</code> - 未授权 请求要求身份验证。对于需要登录的网页，服务器可能返回此响应</li><li><code>403</code> - 禁止 服务器拒绝请求</li><li><code>404</code> - 未找到 服务器找不到请求的网页</li><li>405 - 方法禁用 禁用请求中指定的方法</li><li>406 - 不接受 无法使用请求的内容特性响应请求的网页</li><li><code>407</code> - 需要代理授权 此状态码与 401（未授权）类似，但指定请求者应当授权使用代理</li><li><code>408</code> - 请求超时 服务器等候请求时发生超时</li><li>410 - 已删除 如果请求的资源已永久删除，服务器就会返回此响应</li><li><code>413</code> - 请求实体过大 服务器无法处理请求，因为请求实体过大，超出了服务器的处理能力</li><li><code>414</code> - 请求的 URI 过长 请求的 URI（通常为网址）过长，服务器无法处理</li></ul></li><li><p>5xx（服务器错误）这些状态码表示服务器在尝试处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错</p><ul><li><code>500</code> - 服务器内部错误 服务器遇到错误，无法完成请求</li><li>501 - 尚未实施 服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码</li><li><code>502</code> - 错误网关 服务器作为网关或代理，从上游服务器无法收到无效响应</li><li><code>503</code> - 服务器不可用 服务器目前无法使用（由于超载或者停机维护）。通常，这只是暂时状态</li><li><code>504</code> - 网关超时 服务器作为网关代理，但是没有及时从上游服务器收到请求</li><li>505 - HTTP 版本不受支持 服务器不支持请求中所用的 HTTP 协议版本</li></ul></li></ul><h3 id="介绍下-304-过程"><a href="#介绍下-304-过程" class="headerlink" title="介绍下 304 过程"></a>介绍下 304 过程</h3><ul><li><p>a. 浏览器请求资源时首先命中资源的 Expires 和 Cache-Control，Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效，可以通过 Cache-control: max-age 指定最大生命周期，状态仍然返回 200，但不会请求数据，在浏览器中能明显看到 from cache 字样。</p></li><li><p>b. 强缓存失效，进入协商缓存阶段，首先验证 ETagETag 可以保证每一个资源是唯一的，资源变化都会导致 ETag 变化。服务器根据客户端上送的 If-None-Match 值来判断是否命中缓存。</p></li><li><p>c. 协商缓存 Last-Modify&#x2F;If-Modify-Since 阶段，客户端第一次请求资源时，服务服返回的 header 中会加上 Last-Modify，Last-modify 是一个时间标识该资源的最后修改时间。再次请求该资源时，request 的请求头中会包含 If-Modify-Since，该值为缓存之前返回的 Last-Modify。服务器收到 If-Modify-Since 后，根据资源的最后修改时间判断是否命中缓存。</p></li></ul><h3 id="浏览器的缓存机制-强制缓存-amp-amp-协商缓存"><a href="#浏览器的缓存机制-强制缓存-amp-amp-协商缓存" class="headerlink" title="浏览器的缓存机制 强制缓存 &amp;&amp; 协商缓存"></a>浏览器的缓存机制 强制缓存 &amp;&amp; 协商缓存</h3><p>浏览器与服务器通信的方式为应答模式，即是：浏览器发起 HTTP 请求 – 服务器响应该请求。那么浏览器第一次向服务器发起该请求后拿到请求结果，会根据响应报文中 HTTP 头的缓存标识，决定是否缓存结果，是则将请求结果和缓存标识存入浏览器缓存中，简单的过程如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05b3fe9c411f4881a8b22fe37eae170b~tplv-k3u1fbpfcp-zoom-1.image" alt="图片"></p><p>由上图我们可以知道：</p><ul><li>浏览器每次发起请求，都会<code>先在浏览器缓存中查找该请求的结果以及缓存标识</code></li><li>浏览器每次拿到返回的请求结果都会<code>将该结果和缓存标识存入浏览器缓存中</code></li></ul><p>以上两点结论就是浏览器缓存机制的关键，他确保了每个请求的缓存存入与读取，只要我们再理解浏览器缓存的使用规则，那么所有的问题就迎刃而解了。为了方便理解，这里根据是否需要向服务器重新发起 HTTP 请求将缓存过程分为两个部分，分别是<code>强制缓存</code>和<code>协商缓存</code>。</p><ul><li><p><strong>强制缓存</strong></p><p><code>强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程。</code>当浏览器向服务器发起请求时，服务器会将缓存规则放入 HTTP 响应报文的 HTTP 头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是 <code>Expires</code> 和 <code>Cache-Control</code>，其中 Cache-Control 优先级比 Expires 高。</p><p>强制缓存的情况主要有三种(暂不分析协商缓存过程)，如下：</p><ol><li>不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求（跟第一次发起请求一致）。</li><li>存在该缓存结果和缓存标识，但该结果已失效，强制缓存失效，则使用协商缓存。</li><li>存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果</li></ol></li><li><p><strong>协商缓存</strong></p><p><code>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程</code>，同样，协商缓存的标识也是在响应报文的 HTTP 头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：<code>Last-Modified / If-Modified-Since</code> 和 <code>Etag / If-None-Match</code>，其中 Etag &#x2F; If-None-Match 的优先级比 Last-Modified &#x2F; If-Modified-Since 高。协商缓存主要有以下两种情况：</p><ol><li>协商缓存生效，返回 304</li><li>协商缓存失效，返回 200 和请求结果结果</li></ol></li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e0ce991db4847b98d9f049f9ffa5c93~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>传送门 ☞ <a href="https://juejin.cn/post/6992843117963509791" title="https://juejin.cn/post/6992843117963509791"># 彻底理解浏览器的缓存机制</a></p><h3 id="HTTP-请求跨域问题-1"><a href="#HTTP-请求跨域问题-1" class="headerlink" title="HTTP 请求跨域问题"></a>HTTP 请求跨域问题</h3><ol><li><p>跨域的原理</p><p><strong>跨域</strong>，是指浏览器不能执行其他网站的脚本。它是由浏览器的<code>同源策略</code>造成的。跨域访问是被各大浏览器所默认禁止的。<br><strong>同源策略</strong>,是浏览器对 JavaScript 实施的安全限制，只要<code>协议、域名、端口</code>有任何一个不同，都被当作是不同的域。<br><strong>跨域原理</strong>，即是通过各种方式，<code>避开浏览器的安全限制</code>。</p></li><li><p>解决方案</p><p>最初做项目的时候，使用的是 jsonp，但存在一些问题，使用 get 请求不安全，携带数据较小，后来也用过 iframe，但只有主域相同才行，也是存在些问题，后来通过了解和学习发现使用代理和 proxy 代理配合起来使用比较方便，就引导后台按这种方式做下服务器配置，在开发中使用 proxy，在服务器上使用 nginx 代理，这样开发过程中彼此都方便，效率也高；现在 h5 新特性还有 windows.postMessage()</p><ul><li><p><strong>JSONP</strong>：<br>ajax 请求受同源策略影响，不允许进行跨域请求，而 script 标签 src 属性中的链 接却可以访问跨域的 js 脚本，利用这个特性，服务端不再返回 JSON 格式的数据，而是 返回一段调用某个函数的 js 代码，在 src 中进行了调用，这样实现了跨域。</p><p>步骤：</p><ol><li>去创建一个 script 标签</li><li>script 的 src 属性设置接口地址</li><li>接口参数，必须要带一个自定义函数名，要不然后台无法返回数据</li><li>通过定义函数名去接受返回的数据</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//动态创建 script</span><br><span class="hljs-keyword">var</span> script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;script&quot;</span>);<br><br><span class="hljs-comment">// 设置回调函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getData</span>(<span class="hljs-params">data</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>&#125;<br><br><span class="hljs-comment">//设置 script 的 src 属性，并设置请求地址</span><br>script.<span class="hljs-property">src</span> = <span class="hljs-string">&quot;http://localhost:3000/?callback=getData&quot;</span>;<br><br><span class="hljs-comment">// 让 script 生效</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(script);<br></code></pre></td></tr></table></figure><p><strong>JSONP 的缺点</strong>:<br>JSON 只支持 get，因为 script 标签只能使用 get 请求； JSONP 需要后端配合返回指定格式的数据。</p></li><li><p><strong>document.domain</strong> 基础域名相同 子域名不同</p></li><li><p><strong>window.name</strong> 利用在一个浏览器窗口内，载入所有的域名都是共享一个 window.name</p></li><li><p><strong>CORS</strong><br>CORS(Cross-origin resource sharing)跨域资源共享 是一种机制，是目前主流的跨域解决方案，它使用额外的 HTTP 头来告诉浏览器 让运行在一个 origin (domain) 上的 Web 应用被准许访问来自不同源服务器上的指定的资源。服务器设置对 CORS 的支持原理：服务器设置 Access-Control-Allow-Origin HTTP 响应头之后，浏览器将会允许跨域请求</p><pre><code class="hljs">1.浏览器端会自动向请求头添加origin字段，表明当前请求来源。\2.服务器设置Access-Control-Allow-Origin、Access-Control-Allow-Methods、Access-Control-Allow-Headers等 HTTP响应头字段之后，浏览器将会允许跨域请求。**预检**但是还有复杂一点的请求，我们需要先发OPTIONS请求，a.com想请求b.com它需要发一个自定义的Headers：X-ABC和content-type，这个时候就不是简单请求了， a.com要给b.com 发一个options请求，它其实在问b.com我用post行不行，还想在Headers中带X-ABC和content-type；并不是所有的headers都发这个OPTIONS请求，因为X-ABC是自定义的，所以需要发；b.com看到OPTIONS请求，先不会返回数据，先检查自己的策略，看看能不能支持这次请求，如果支持就返回200。OPTIONS请求返回以下报文HTTP/2.0 20 OKAccess-Control-Allow-Origin:https://a.comAccess-Control-Allow-Methods:POST,GET,OPTIONSAccess-Control-Allow-Headers:X-ABC,Content-Type    Access-Control-Max-Age:86400 // 告诉浏览器这个策略生效时间为一个小时，在一个小时之内发送类似的请求，不用在问服务端了，相当于缓存了浏览器收到了OPTIONS的返回，会在发一次，这一次才是真正的请求数据，这次headers会带上X-ABC、contentType。整体的过程cors将请求分为2种，简单请求和复杂请求，需不需要发送OPTIONS浏览器说的算，浏览器判断是简单请求还是复杂请求，cors是非常广泛的跨域手段 这里的缺点是OPTIONS请求也是一次请求，消耗带宽，真正的请求也会延迟。</code></pre></li><li><p>最方便的跨域方案 <strong>proxy 代理+ Nginx</strong><br>nginx 是一款极其强大的 web 服务器，其优点就是轻量级、启动快、高并发。</p><p>跨域问题的产生是因为浏览器的同源政策造成的，但是服务器与服务器之间的数据交换是没有这个限制。</p><p>反向代理就是采用这种方式，建立一个虚拟的代理服务器来接收 internet 上的链接请求，然后转发给内部网络上的服务器，并将从服务器上得到的结果，返回给 internet 上请求链接的客户端。现在的新项目中 nginx 几乎是首选，我们用 node 或者 java 开发的服务通常都需要经过 nginx 的反向代理。</p></li><li><p><strong>window.postMessage()</strong> 利用 h5 新特性 window.postMessage()</p></li></ul></li></ol><p>跨域传送门 ☞ <a href="https://juejin.cn/post/7003232769182547998"># 跨域，不可不知的基础概念</a></p><h3 id="粘包问题分析与对策"><a href="#粘包问题分析与对策" class="headerlink" title="粘包问题分析与对策"></a>粘包问题分析与对策</h3><p>TCP 粘包是指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。</p><p><strong>粘包出现原因</strong></p><p>简单得说，在流传输中出现，UDP 不会出现粘包，因为它有<strong>消息边界</strong></p><p>粘包情况有两种，一种是<code>粘在一起的包都是完整的数据包</code>，另一种情况是<code>粘在一起的包有不完整的包</code>。</p><p>为了<strong>避免粘包</strong>现象，可采取以下几种措施：</p><p>（1）对于发送方引起的粘包现象，用户可通过编程设置来避免，<code>TCP提供了强制数据立即传送的操作指令push</code>，TCP 软件收到该操作指令后，就立即将本段数据发送出去，而不必等待发送缓冲区满；</p><p>（2）对于接收方引起的粘包，则可通过优化程序设计、精简接收进程工作量、<code>提高接收进程优先级等措施</code>，使其及时接收数据，从而尽量避免出现粘包现象；</p><p>（3）由接收方控制，将一包数据按结构字段，人为控制分多次接收，然后合并，通过这种手段来避免粘包。<code>分包多发</code>。</p><p>以上提到的三种措施，都有其不足之处。</p><p>（1）第一种编程设置方法虽然可以避免发送方引起的粘包，但它关闭了优化算法，降低了网络发送效率，影响应用程序的性能，一般不建议使用。</p><p>（2）第二种方法只能减少出现粘包的可能性，但并不能完全避免粘包，当发送频率较高时，或由于网络突发可能使某个时间段数据包到达接收方较快，接收方还是有可能来不及接收，从而导致粘包。</p><p>（3）第三种方法虽然避免了粘包，但应用程序的效率较低，对实时应用的场合不适合。</p><blockquote><p>一种比较周全的对策是：接收方创建一预处理线程，对接收到的数据包进行预处理，将粘连的包分开。实验证明这种方法是高效可行的。</p></blockquote><h3 id="客户端与服务端长连接的几种方式"><a href="#客户端与服务端长连接的几种方式" class="headerlink" title="客户端与服务端长连接的几种方式"></a>客户端与服务端长连接的几种方式</h3><ol><li><p><strong>ajax 轮询</strong><br><strong>实现原理</strong>：ajax 轮询指客户端每间隔一段时间向服务端发起请求，保持数据的同步。</p><p><strong>优点</strong>：可实现基础（指间隔时间较短）的数据更新。</p><p><strong>缺点</strong>：这种方法也只是尽量的模拟即时传输，但并非真正意义上的即时通讯，很有可能出现客户端请求时，服务端数据并未更新。或者服务端数据已更新，但客户端未发起请求。导致多次请求资源浪费，效率低下。【<code>数据更新不及时，效率低下</code>】</p></li><li><p><strong>long poll 长轮询</strong></p><p><strong>实现原理</strong>：<br>long poll 指的是客户端发送请求之后，如果没有数据返回，服务端会将请求挂起放入队列（不断开连接）处理其他请求，直到有数据返回给客户端。然后客户端再次发起请求，以此轮询。在 HTTP1.0 中客户端可以设置请求头 Connection:keep-alive，服务端收到该请求头之后知道这是一个长连接，在响应报文头中也添加 Connection:keep-alive。客户端收到之后表示长连接建立完成，可以继续发送其他的请求。在 HTTP1.1 中默认使用了 Connection:keep-alive 长连接。</p><p><strong>优点</strong>：减少客户端的请求，降低无效的网络传输，保证每次请求都有数据返回，不会一直占用线程。</p><p><strong>缺点</strong>：无法处理高并发，当客户端请求量大，请求频繁时对服务器的处理能力要求较高。服务器一直保持连接会消耗资源，需要同时维护多个线程，服务器所能承载的 TCP 连接数是有上限的，这种轮询很容易把连接数顶满。每次通讯都需要客户端发起，服务端不能主动推送。【<code>无法处理高并发，消耗服务器资源严重，服务端不能主动推送</code>】</p></li><li><p><strong>iframe 长连接</strong></p><p><strong>实现原理：</strong><br>在网页上嵌入一个 iframe 标签，该标签的 src 属性指向一个长连接请求。这样服务端就可以源源不断地给客户端传输信息。保障信息实时更新。</p><p><strong>优点</strong>：消息及时传输。</p><p><strong>缺点</strong>：<code>消耗服务器资源</code>。</p></li><li><p><strong>WebSocket</strong></p><p><strong>实现原理</strong>：<br>Websocket 实现了客户端与服务端的双向通信，只需要连接一次，就可以相互传输数据，很适合实时通讯、数据实时更新等场景。</p><p>Websocket 协议与 HTTP 协议没有关系，它是一个建立在 TCP 协议上的全新协议，为了兼容 HTTP 握手规范，在握手阶段依然使用 HTTP 协议，握手完成之后，数据通过 TCP 通道进行传输。</p><p>Websoket 数据传输是通过 frame 形式，一个消息可以分成几个片段传输。这样大数据可以分成一些小片段进行传输，不用考虑由于数据量大导致标志位不够的情况。也可以边生成数据边传递消息，提高传输效率。</p><p><strong>优点</strong>：<br>双向通信。客户端和服务端双方都可以主动发起通讯。<br>没有同源限制。客户端可以与任意服务端通信，不存在跨域问题。<br>数据量轻。第一次连接时需要携带请求头，后面数据通信都不需要带请求头，减少了请求头的负荷。<br>传输效率高。因为只需要一次连接，所以数据传输效率高。</p><p><strong>缺点</strong>：<br>长连接需要后端处理业务的代码更稳定，推送消息相对复杂；<br>长连接受网络限制比较大，需要处理好重连。<br>兼容性，WebSocket 只支持 IE10 及其以上版本。<br>服务器长期维护长连接需要一定的成本，各个浏览器支持程度不一；<br>成熟的 HTTP 生态下有大量的组件可以复用，WebSocket 则没有，遇到异常问题难以快速定位快速解决。【需要后端代码稳定，受网络限制大，兼容性差，维护成本高，生态圈小】</p></li></ol><h3 id="利用-Socket-建立网络连接的步骤"><a href="#利用-Socket-建立网络连接的步骤" class="headerlink" title="利用 Socket 建立网络连接的步骤"></a>利用 Socket 建立网络连接的步骤</h3><p>建立 Socket 连接至少需要一对套接字，其中一个运行于客户端，称为 ClientSocket ，另一个运行于服务器端，称为 ServerSocket 。</p><p>套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认。</p><p>1、服务器监听：服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求。</p><p>2、客户端请求：指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。</p><p>为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。</p><p>3、连接确认：当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户端，一旦客户端确认了此描述，双方就正式建立连接。</p><p>而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。</p><h3 id="非对称加密-RSA"><a href="#非对称加密-RSA" class="headerlink" title="非对称加密 RSA"></a>非对称加密 RSA</h3><p>简介：</p><ol><li>对称加密算法又称现代加密算法。</li><li>非对称加密是计算机通信安全的基石，保证了加密数据不会被破解。</li><li>非对称加密算法需要两个密钥：公开密钥(publickey) 和私有密(privatekey)</li><li>公开密钥和私有密钥是一对</li></ol><p>如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密。 <br>如果用私有密钥对数据进行加密，只有用对应的公开密钥才能解密。</p><p>特点： <br>算法强度复杂，安全性依赖于算法与密钥。 <br>加密解密速度慢。</p><p>与对称加密算法的对比： <br>对称加密只有一种密钥，并且是非公开的，如果要解密就得让对方知道密钥。 <br>非对称加密有两种密钥，其中一个是公开的。</p><p>RSA 应用场景： <br>由于 RSA 算法的加密解密速度要比对称算法速度慢很多，在实际应用中，通常采取  <br>数据本身的加密和解密使用对称加密算法(AES)。  用 RSA 算法加密并传输对称算法所需的密钥。</p><h3 id="HTTP1、HTTP2、HTTP3"><a href="#HTTP1、HTTP2、HTTP3" class="headerlink" title="HTTP1、HTTP2、HTTP3"></a>HTTP1、HTTP2、HTTP3</h3><p>HTTP&#x2F;2 相比于 HTTP&#x2F;1.1，可以说是大幅度提高了网页的性能，只需要升级到该协议就可以减少很多之前需要做的性能优化工作，虽如此但 HTTP&#x2F;2 并非完美的，HTTP&#x2F;3 就是为了解决 HTTP&#x2F;2 所存在的一些问题而被推出来的。</p><h3 id="HTTP1-1-的缺陷"><a href="#HTTP1-1-的缺陷" class="headerlink" title="HTTP1.1 的缺陷"></a><strong>HTTP1.1 的缺陷</strong></h3><ol><li><p>高延迟 — 队头阻塞(Head-Of-Line Blocking)</p><p><code>队头阻塞</code>是指当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一并被阻塞，会导致客户端迟迟收不到数据。</p><p>针对队头阻塞的解决办法:</p><ul><li><code>将同一页面的资源分散到不同域名下，提升连接上限</code>。</li><li><code>合并小文件减少资源数</code>，使用精灵图。</li><li><code>内联(Inlining)资源</code>是另外一种防止发送很多小图请求的技巧，将图片的原始数据嵌入在 CSS 文件里面的 URL 里，减少网络请求次数。</li><li><code>减少请求数量</code>，合并文件。</li></ul></li><li><p>无状态特性 — 阻碍交互</p><p><code>无状态是指协议对于连接状态没有记忆能力</code>。纯净的 HTTP 是没有 cookie 等机制的，每一个连接都是一个新的连接。</p><p><code>Header里携带的内容过大，在一定程度上增加了传输的成本</code>。且请求响应报文里有大量字段值都是重复的。</p></li><li><p>明文传输 — 不安全性</p><p>HTTP&#x2F;1.1 在传输数据时，所有<code>传输的内容都是明文</code>，客户端和服务器端都无法验证对方的身份，无法保证数据的安全性。</p></li><li><p>不支持服务端推送</p></li></ol><blockquote><p>记忆口诀：队头阻塞高延迟，无状态阻交互，明文传输不安全，服务推送不支持。</p></blockquote><p><strong>HTTP 1.1 排队问题</strong></p><p>HTTP 1.1 多个文件共用一个 TCP，这样可以减少 tcp 握手，这样 3 个文件就不用握手 9 次了，不过这样请求文件需要排队，请求和返回都需要排队， 如果第一个文件响应慢，会阻塞后面的文件，这样就产生了对头的等待问题。</p><p>有的网站可能会有很多文件，浏览器处于对机器性能的考虑，它不可能让你无限制的发请求建连接，因为建立连接需要占用资源，浏览器不想把用户的网络资源都占用了，所以浏览器最多会建立 6 个 tcp 连接；如果有上百个文件可能都需要排队，http2.0 正在解决这个问题。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8ecdc60670194df7957ee59e1f56701f~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h3 id="SPDY-协议与-HTTP-x2F-2-简介"><a href="#SPDY-协议与-HTTP-x2F-2-简介" class="headerlink" title="SPDY 协议与 HTTP&#x2F;2 简介"></a>SPDY 协议与 HTTP&#x2F;2 简介</h3><h4 id="1、HTTP-x2F-2-简介"><a href="#1、HTTP-x2F-2-简介" class="headerlink" title="1、HTTP&#x2F;2 简介"></a>1、HTTP&#x2F;2 简介</h4><p>HTTP&#x2F;2 是现行 HTTP 协议（HTTP&#x2F;1.x）的替代，但它不是重写。<strong>HTTP&#x2F;2 基于 SPDY，专注于性能，最大的一个目标是在用户和网站间只用一个连接（connection）</strong> 。</p><h4 id="2、HTTP-x2F-2-新特性"><a href="#2、HTTP-x2F-2-新特性" class="headerlink" title="2、HTTP&#x2F;2 新特性"></a>2、HTTP&#x2F;2 新特性</h4><h4 id="1、二进制传输"><a href="#1、二进制传输" class="headerlink" title="1、二进制传输"></a>1、二进制传输</h4><p><code>HTTP/2传输数据量的大幅减少,主要有两个原因:以二进制方式传输和Header 压缩</code>。我们先来介绍二进制传输,HTTP&#x2F;2 采用二进制格式传输数据，而非 HTTP&#x2F;1.x 里纯文本形式的报文 ，二进制协议解析起来更高效。<code>HTTP/2 将请求和响应数据分割为更小的帧，并且它们采用二进制编码</code>。</p><h4 id="2、Header-压缩"><a href="#2、Header-压缩" class="headerlink" title="2、Header 压缩"></a>2、Header 压缩</h4><p>HTTP&#x2F;2 并没有使用传统的压缩算法，而是开发了专门的”HPACK”算法，在客户端和服务器两端建立“字典”，用索引号表示重复的字符串，还采用哈夫曼编码来压缩整数和字符串，可以达到 50%~90%的高压缩率。</p><h4 id="3、多路复用"><a href="#3、多路复用" class="headerlink" title="3、多路复用"></a>3、多路复用</h4><p>在 HTTP&#x2F;2 中引入了多路复用的技术。多路复用很好的解决了浏览器限制同一个域名下的请求数量的问题，同时也更容易实现全速传输。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f756ad3403bc4fe18e970c56677c796e~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h4 id="4、Server-Push"><a href="#4、Server-Push" class="headerlink" title="4、Server Push"></a>4、Server Push</h4><p>HTTP2 还在一定程度上改变了传统的“请求-应答”工作模式，服务器不再是完全被动地响应请求，也可以新建“流”主动向客户端发送消息。减少等待的延迟，这被称为”<code>服务器推送</code>“（ Server Push，也叫 Cache push）</p><h4 id="5、提高安全性"><a href="#5、提高安全性" class="headerlink" title="5、提高安全性"></a>5、提高安全性</h4><p>出于兼容的考虑，HTTP&#x2F;2 延续了 HTTP&#x2F;1 的“明文”特点，可以像以前一样使用明文传输数据，不强制使用加密通信，不过格式还是二进制，只是不需要解密。</p><p>但由于 HTTPS 已经是大势所趋，而且主流的浏览器 Chrome、Firefox 等都公开宣布只支持加密的 HTTP&#x2F;2，<strong>所以“事实上”的 HTTP&#x2F;2 是加密的</strong>。也就是说，互联网上通常所能见到的 HTTP&#x2F;2 都是使用”https”协议名，跑在 TLS 上面。HTTP&#x2F;2 协议定义了两个字符串标识符：“h2”表示加密的 HTTP&#x2F;2，“h2c”表示明文的 HTTP&#x2F;2。</p><h4 id="6、防止对头阻塞"><a href="#6、防止对头阻塞" class="headerlink" title="6、防止对头阻塞"></a>6、防止对头阻塞</h4><p>http1.1 如果第一个文件阻塞，第二个文件也就阻塞了。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b67bd1f793a3425d9e8a415cae9b7863~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>http2.0 的解决，把 3 个请求打包成一个小块发送过去，即使第一个阻塞了，后面 2 个也可以回来；相当于 3 个文件同时请求，就看谁先回来谁后回来，阻塞的可能就后回来，对带宽的利用是最高的；但没有解决 TCP 的对头阻塞，如果 TCP 发过去的一个分包发丢了，他会重新发一次；http2.0 的解决了大文件的阻塞。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/77d8ae8e0de44f3aa693f0626a346d4c~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>一个分包请求 3 个文件，即使第一个阻塞了，第二个也能返回</p><h3 id="HTTP-x2F-2-的缺点"><a href="#HTTP-x2F-2-的缺点" class="headerlink" title="HTTP&#x2F;2 的缺点"></a>HTTP&#x2F;2 的缺点</h3><p>虽然 HTTP&#x2F;2 解决了很多之前旧版本的问题，但它还是存在一个巨大的问题，<strong>主要是底层支撑的 TCP 协议造成的</strong>。HTTP&#x2F;2 的缺点主要有以下几点：</p><ol><li>TCP 以及 TCP+TLS 建立连接时延时</li><li>TCP 的队头阻塞并没有彻底解决</li><li>多路复用导致服务器压力上升也容易 Timeout</li></ol><h3 id="HTTP-x2F-3-新特性"><a href="#HTTP-x2F-3-新特性" class="headerlink" title="HTTP&#x2F;3 新特性"></a>HTTP&#x2F;3 新特性</h3><h4 id="1、HTTP-x2F-3-简介"><a href="#1、HTTP-x2F-3-简介" class="headerlink" title="1、HTTP&#x2F;3 简介"></a>1、HTTP&#x2F;3 简介</h4><p>Google 在推 SPDY 的时候就搞了个基于 UDP 协议的“QUIC”协议，让 HTTP 跑在 QUIC 上而不是 TCP 上。而“HTTP over QUIC”就是 HTTP&#x2F;3，真正“完美”地解决了“队头阻塞”问题。</p><p>QUIC 虽然基于 UDP，但是在原本的基础上新增了很多功能，接下来我们重点介绍几个 QUIC 新功能。</p><h4 id="2、QUIC-新功能"><a href="#2、QUIC-新功能" class="headerlink" title="2、QUIC 新功能"></a>2、QUIC 新功能</h4><p>QUIC 基于 UDP，而 UDP 是“无连接”的，根本就不需要“握手”和“挥手”，所以就比 TCP 来得快。此外 QUIC 也实现了可靠传输，保证数据一定能够抵达目的地。它还引入了类似 HTTP&#x2F;2 的“流”和“多路复用”，单个“流”是有序的，可能会因为丢包而阻塞，但其他“流”不会受到影响。具体来说 QUIC 协议有以下特点：</p><ul><li><p><strong>实现了类似 TCP 的流量控制、传输可靠性的功能</strong></p><p>虽然 UDP 不提供可靠性的传输，但 QUIC 在 UDP 的基础之上增加了一层来保证数据可靠性传输。它提供了数据包重传、拥塞控制以及其他一些 TCP 中存在的特性。</p></li><li><p><strong>实现了快速握手功能</strong></p><p>由于 QUIC 是基于 UDP 的，所以 QUIC 可以实现使用 0-RTT 或者 1-RTT 来建立连接，这意味着 QUIC 可以用最快的速度来发送和接收数据，这样可以大大提升首次打开页面的速度。<strong>0RTT 建连可以说是 QUIC 相比 HTTP2 最大的性能优势</strong>。</p></li><li><p><strong>集成了 TLS 加密功能</strong></p></li><li><p><strong>多路复用，彻底解决 TCP 中队头阻塞的问题</strong></p><p>和 TCP 不同，QUIC 实现了在同一物理连接上可以有多个独立的逻辑数据流。实现了数据流的单独传输，就解决了 TCP 中队头阻塞的问题。</p></li><li><p><strong>连接迁移</strong></p><p>TCP 是按照 4 要素（客户端 IP、端口, 服务器 IP、端口）确定一个连接的。而 QUIC 则是让客户端生成一个 Connection ID （64 位）来区别不同连接。只要 Connection ID 不变，连接就不需要重新建立，即便是客户端的网络发生变化。由于迁移客户端继续使用相同的会话密钥来加密和解密数据包，QUIC 还提供了迁移客户端的自动加密验证。</p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>HTTP&#x2F;1.1 有两个主要的缺点：安全不足和性能不高。</li><li>HTTP&#x2F;2 完全兼容 HTTP&#x2F;1，是“更安全的 HTTP、更快的 HTTPS”，二进制传输、头部压缩、多路复用、服务器推送等技术可以充分利用带宽，降低延迟，从而大幅度提高上网体验；</li><li>QUIC 基于 UDP 实现，是 HTTP&#x2F;3 中的底层支撑协议，该协议基于 UDP，又取了 TCP 中的精华，实现了即快又可靠的协议。</li></ul><h3 id="理解-xss，csrf，ddos-攻击原理以及避免方式"><a href="#理解-xss，csrf，ddos-攻击原理以及避免方式" class="headerlink" title="理解 xss，csrf，ddos 攻击原理以及避免方式"></a>理解 xss，csrf，ddos 攻击原理以及避免方式</h3><p><code>XSS</code>(<code>Cross-Site Scripting</code>，<strong>跨站脚本攻击</strong>)是一种代码注入攻击。攻击者在目标网站上注入恶意代码，当被攻击者登陆网站时就会执行这些恶意代码，这些脚本可以读取 <code>cookie，session tokens</code>，或者其它敏感的网站信息，对用户进行钓鱼欺诈，甚至发起蠕虫攻击等。</p><p><code>CSRF</code>（<code>Cross-site request forgery</code>）<strong>跨站请求伪造</strong>：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。</p><p><strong>XSS 避免方式：</strong></p><ol><li><code>url</code>参数使用<code>encodeURIComponent</code>方法转义</li><li>尽量不是有<code>InnerHtml</code>插入<code>HTML</code>内容</li><li>使用特殊符号、标签转义符。</li></ol><p><code>CSRF</code>避免方式：</p><ol><li><p>添加验证码</p></li><li><p>使用 token</p><ul><li>服务端给用户生成一个 token，加密后传递给用户</li><li>用户在提交请求时，需要携带这个 token</li><li>服务端验证 token 是否正确</li></ul></li></ol><p><code>DDoS</code>又叫分布式拒绝服务，全称 <code>Distributed Denial of Service</code>，其原理就是利用大量的请求造成资源过载，导致服务不可用。</p><p><strong><code>DDos</code>避免方式：</strong></p><ol><li>限制单 IP 请求频率。</li><li>防火墙等防护设置禁止<code>ICMP</code>包等</li><li>检查特权端口的开放</li></ol><p><a href="https://mp.weixin.qq.com/s?__biz=MzkzNzI0MDMxNQ==&mid=2247487116&idx=1&sn=09187eeb7e45faa1bee86ff48ae14be1&source=41#wechat_redirect">360 技术：嗨，送你一张 Web 性能优化地图</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>http</tag>
      
      <tag>https</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
